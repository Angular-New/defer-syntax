# Defer Angular

## Links

- [Angular @defer: Complete Guide](https://blog.angular-university.io/angular-defer/)

Один из наиболее эффективных методов повышения производительности одностраничного приложения — максимально отсрочить загрузку некритичных ресурсов.

Критические ресурсы следует загружать в первую очередь, а другие менее важные ресурсы следует загружать позже, только тогда и при необходимости.

Существует большая вероятность того, что большая часть вашей базы кода не понадобится для типичного пользовательского сеанса.

Так зачем же загружать код, в котором мы не уверены на 100%, что он нам понадобится? Загрузка ненужного кода просто замедляет наше приложение.

В Angular до сих пор был один основной встроенный механизм, позволяющий избежать загрузки ненужных ресурсов: **отложенная загрузка** на основе маршрутизатора.

Этот механизм очень мощный, но у него есть ограничение: он не позволяет лениво **загружать части данного шаблона**.

Но что, если у вас большой экран с множеством зависимостей, и вы хотите **загружать части страницы**, которые не видны сразу в фоновом режиме, пока вы ждете, пока пользователь прокрутит страницу вниз или нажмет кнопку?

Этот тип **очень детальной отложенной загрузки** просто невозможен при отложенной загрузке на основе маршрутизатора.

Но это именно то, что умеет `@defer`!

`@defer` позволяет реализовать все эти сценарии и многое другое.

В этом руководстве мы рассмотрим, как использовать синтаксис шаблонов `@defer`, чтобы поднять производительность ваших приложений Angular на новый уровень.

Мы также объясним ее связь с отложенной загрузкой и ее сравнение с ней.

Оглавление

В этом посте рассматриваются следующие темы:

    Что такое @defer и зачем он нам нужен?
    @defer в действии
    @defer с @placeholder
    Параметры @placeholder
    @defer с @loading
    Разница между @placeholder и @loading
    @defer с @error
    Как работают триггеры @defer?
    Встроенный триггер холостого хода
    Встроенный триггер области просмотра с @placeholder
    Встроенный триггер области просмотра без @placeholder
    Встроенный триггер взаимодействия с @placeholder
    Встроенный триггер взаимодействия без @placeholder
    Встроенный триггер наведения с @placeholder
    Встроенный триггер наведения без @placeholder
    Немедленный встроенный триггер
    Встроенный триггер таймера
    Предварительная выборка блоков @defer
    Предварительная выборка в окне просмотра, отображение при взаимодействии
    Пользовательские триггеры @defer с ключевым словом When
    Что происходит, когда @defer используется при рендеринге на стороне сервера?
    Чем @defer отличается от отложенной загрузки?
    Что можно загрузить с помощью @defer?
    Чем @defer отличается от @if?
    Краткое содержание

Что такое `@defer` и зачем нам это нужно?

`@defer` — это синтаксис шаблона Angular, который позволяет **загружать части шаблона** только тогда, когда они необходимы, при наличии **логического условия**.

Синтаксис `@defer` позволяет нам реализовать распространенные случаи использования, такие как:

- загружать большой компонент только после того, как пользователь прокрутит страницу вниз после определенной точки
- загружать большой компонент только после того, как пользователь нажмет кнопку 
- предварительно загружать большой компонент в фоновом режиме, пока пользователь читает страницу, чтобы он был готов к тому моменту, когда пользователь нажмет кнопку

И это лишь несколько распространенных примеров того, что мы можем сделать с `@defer`.

Синтаксис `@defer` дает нам два уровня контроля над процессом загрузки частичных ресурсов:

    мы можем контролировать , когда код будет получен из серверной части, и это называется предварительной выборкой .

    мы также можем отдельно контролировать , когда этот код применяется к странице.

Важно понимать, что эти два шага — не одно и то же.

Возможно, вы захотите загрузить некоторый код в фоновом режиме, ожидая, что он скоро понадобится, но вам не обязательно отображать этот код сразу после его загрузки.

Возможно, вам захочется дождаться определенного события, например нажатия пользователем кнопки, прежде чем отображать код.

С помощью @deferмы можем определить триггеры для каждого из этих двух шагов отдельно.

Мы можем использовать предопределенные триггеры, но при необходимости мы также можем определить наши собственные триггеры.

Таким образом, у нас есть полная гибкость в отношении всего процесса загрузки и применения кода.

В общем, предопределенных триггеров будет более чем достаточно для большинства случаев использования.

Давайте тогда посмотрим @deferв действии!
@deferВ бою

Представьте, что у вашего компонента есть некий код, который будет отображаться всегда, но есть раздел страницы, который нужен только в определенных сценариях.

Этот несущественный раздел содержит большой компонент, который мы хотим загрузить в фоновом режиме.

Вот простой пример этого компонента:

@Component({
selector: "large-component",
template: ` <h2>large-component is displayed...</h2> `,
})
export class ExampleComponent {}

Только представьте, что это массивный компонент, который внутри использует библиотеки диаграмм и другие тяжелые зависимости.

Мы хотим отложить загрузку этого большого компонента до тех пор, пока не будем на 100% уверены, что он нужен пользователю.

Чтобы контролировать, когда этот большой компонент загружается в наше приложение, начните с того, что заключите его в @deferблок:

@Component({
selector: "app",
template: `
<h2>Some content that will always be displayed ...</h2>

    @defer {
    <large-component />
    }
`,
})
export class AppComponent {}

Это сообщит Angular, что @deferраздел страницы должен быть упакован в отдельный пакет Javascript и загружен отдельно.

Вы можете увидеть немедленный эффект присутствия блока @deferв выводе сборки Angular CLI:

Вывод сборки Angular CLI, где виден дополнительный пакет, созданный @defer

Как видите, использование привело к @deferсозданию дополнительного пакета, содержащего код элемента large-component.

Это означает, что large-componentвсе его зависимости были извлечены из основного пакета приложения и теперь являются частью отдельного пакета.

Таким образом, основной пакет приложений теперь стал меньше и должен загружаться быстрее!

Новый дополнительный пакет large-componentбудет загружен только тогда, когда @deferблок сработает.

Обратите внимание, что мы не указали триггер для @deferблока, поэтому он будет срабатывать по умолчанию, когда браузер бездействует.

Браузер считается бездействующим, когда все ресурсы страницы завершили загрузку, а счетчик загрузки браузера остановился.

Это означает, что large-componentпакет будет загружен и отображен вскоре после полной визуализации AppComponent.

Чтобы было понятнее, вот что происходит в этот момент:

пакет загружается с помощью @defer

Как мы видим, происходит следующее:

    основной пакет приложения загружается первым
    затем @deferзагружается пакет, содержащий файл large-componentи все его зависимости
    мы видим, что дополнительный пакет загружается последним на вкладке сети в правом нижнем углу.
    затем large-componentрендерится, как мы видим в правом верхнем углу

Итак, это устанавливает основы того, как @deferработает «под капотом».

Но теперь вопрос в том, как мы можем лучше контролировать поведение @defer:

    как мы можем контролировать загрузку пакета?
    как мы можем контролировать время рендеринга large-component?
    можем ли мы отображать индикатор загрузки во время загрузки пакета?
    можем ли мы отобразить сообщение об ошибке, если пакет не загружается?
    можем ли мы отобразить некоторый начальный контент, который будет отображаться до загрузки пакета?

Далее мы ответим на все эти вопросы!

Но чтобы ответить на многие из этих вопросов, нам нужно сначала представить сопутствующие блоки @defer: блоки @placeholder, @loadingи @error.
@deferс@placeholder

Иногда нам просто хочется отобразить пустое место в том месте, где
@deferнаходится наш блок.

Но в других случаях мы хотим отобразить пользователю некоторый исходный контент, который позже будет заменен кодом, загруженным через блок @defer.

Мы можем сделать это, обернув исходный контент, который хотим отобразить, в @placeholderблок:

@defer {
<large-component />
}
@placeholder {
<initial-content />
}

Итак, вот как это работает:

    Изначально <initial-content />компонент рендерится в месте @deferразмещения блока внутри страницы.

    Только когда @deferблок будет загружен и отображен, он будет <initial-content />заменен на <large-component />.

Примечание . Любые компоненты, директивы, каналы и т. д., используемые внутри @placeholder, будут быстро загружены и станут частью основного пакета.

Поэтому не используйте тяжелые зависимости, которые вы хотите загрузить внутри @placeholderблока.

Компонент-заполнитель обычно должен быть чем-то очень простым и легким.

Это просто визуальный индикатор того, что в этом пространстве скоро что-то будет размещено.
@placeholderпараметры

Блок @placeholderможет принимать один необязательный параметр с именем minimum, который представляет собой продолжительность времени в секундах или миллисекундах.

minimumиспользуется для установки минимального количества времени, в течение которого блок-заполнитель будет отображаться пользователю:

Пример:

@defer {
<large-component />
}
@placeholder (minimum 2s) {
<initial-content />
}

Приведенный выше код будет отображать элемент <initial-content />в течение 2 секунд, прежде чем он <large-component />появится.

Это минимальное время отображения полезно для предотвращения неприятных ощущений от пользовательского интерфейса.

Это связано с тем, что в зависимости от скорости сети @deferблок может отображать заполнитель только на долю секунды.

В этом случае пользователь просто увидит на странице какой-то странный эффект мерцания, который может создать ощущение, что что-то сломано, хотя это не так.

Параметр minimumпомогает в этом, поскольку он гарантирует, что заполнитель отображается достаточно долго, чтобы пользователь мог его увидеть и понять, что это такое, прежде чем он исчезнет.
@deferс@loading

Блок @loadingиспользуется для отображения некоторого контента, пока @deferблок все еще загружает пакет Javascript в фоновом режиме.

Пример:

@defer {
<large-component />
}
@loading {
<loading-spinner />
}

Будет <loading-spinner />отображаться только во время <large-component />загрузки пакета. Когда загрузка завершится, элемент <loading-spinner />будет удален со страницы, а <large-component />на его месте будет отображаться элемент.

Обратите внимание, что все зависимости внутри @loadingблока также активно загружаются, как и в случае с @placeholder.

Блок @loadingпринимает два необязательных параметра: minimumи after:

    minimumиспользуется для указания минимального времени, в течение которого @loadingблок будет отображаться пользователю.

    afterиспользуется для указания количества времени, которое нам следует подождать, прежде чем показывать @loadingиндикатор после начала процесса загрузки.

Оба параметра могут быть выражены в секундах или миллисекундах, и оба они предназначены для устранения нежелательных эффектов мерцания в пользовательском интерфейсе.

Вот пример того, как можно комбинировать эти параметры:

@defer {
<large-component />
} @loading (after 1s; minimum 2s) {
<loading-spinner />
}

    Блок @loadingвыше будет ждать 1 секунду после начала загрузки, прежде чем отобразить содержимое своего блока.
    Содержимое блока @loadingбудет отображаться в течение 2 секунд перед его <large-component />рендерингом.

Обратите внимание: если загрузка занимает меньше afterзначения 1 секунды, то элемент @loadingникогда не будет отображаться.

Это значит, что:

    индикатор загрузки будет отображаться только в том случае, если загрузка занимает более 1 секунды, в противном случае он никогда не будет отображаться

    если индикатор загрузки когда-либо отображается, а затем загрузка завершается, мы не хотим, чтобы он слишком быстро скрывался от пользователя.

    поэтому мы установили минимальное время отображения в 2 секунды. Это означает, что если индикатор загрузки вообще появится, он будет отображаться не менее 2 секунд.

Это предотвращает слишком быстрое исчезновение индикатора, что может создать впечатление, что что-то сломано.
Разница между @placeholderи@loading

Эти два блока кажутся похожими, но служат разным целям.

Первоначально отображается @placeholderдо тех пор, пока содержимое блока @deferне будет готово к рендерингу.

Этот блок отображается еще до начала загрузки пакета. Помните, возможно, загрузка инициируется только после того, как пользователь нажмет на кнопку.

Поэтому, пока не запустится загрузка пакета, мы можем захотеть отобразить некоторый контент пользователю, и вот тут-то и @placeholderвозникает необходимость.

С другой стороны, блок @loadingотображается только тогда, когда загрузка пакета блока @deferначалась и все еще продолжается .

После завершения загрузки оно исчезает.
@deferс@error

Но что, если во время загрузки пакета что-то пойдет не так, например, из-за сетевой ошибки?

Блок @errorиспользуется для отображения контента, когда по какой-либо причине загрузка блока @deferне удалась.

Пример:

@defer {
<large-component />
} @error {
<error-message />
}

Итак, теперь, когда мы знакомы с несколькими блоками отсрочки, давайте поговорим о триггерах.
Как @deferработают триггеры?

@deferимеет два уровня управления, каждый со своим триггером:

    дополнительный триггер предварительной выборки, который контролирует загрузку пакета из серверной части

    дополнительный @deferтриггер, который контролирует, когда @deferблок отображается пользователю

Помните, что это два совершенно разных события, и мы можем управлять ими отдельно и поддерживать всевозможные расширенные варианты использования.

Когда дело доходит до выбора правильного триггера, у нас есть два варианта:

    мы можем использовать предопределенные триггеры, которые охватывают все наиболее распространенные случаи использования.

    но мы также можем определить наши собственные триггеры, если это необходимо.

Ключевое слово onиспользуется для предопределенных триггеров, а ключевое слово when— для пользовательских триггеров.

Начнем с предопределенных триггеров, вот полный список:

    праздный
    область просмотра
    взаимодействие
    зависать
    немедленный
    таймер

Все эти предопределенные триггеры можно применять как в качестве триггеров предварительной выборки, так и в качестве @deferтриггеров отображения.

Давайте пройдемся по ним один за другим.
Встроенный триггер холостого хода

Это триггер по умолчанию для @defer, как для предварительной выборки, так и для отображения @deferблока.

Итак, предположим, что мы используем @deferбез какого-либо триггера:

@defer {
<large-component />
}

Это эквивалентно:

@defer (on idle; prefetch on idle) {
<large-component />
}

Обратите внимание, что мы используем onключевое слово, а не when, поскольку это предопределенный триггер.

Как видите, idleэто одновременно триггер предварительной выборки по умолчанию и триггер отображения по умолчанию.

Итак, как это работает?

idleсрабатывает, когда браузер переходит в состояние ожидания.

Это состояние ожидания возникает, когда браузер завершил загрузку всех ресурсов страницы и не занят какой-либо другой задачей.

Angular обнаруживает это с помощью стандартного requestIdleCallbackAPI браузера.

Когда это произойдет? Для большинства приложений браузер будет простаивать сразу после загрузки страницы, когда индикатор загрузки браузера перестанет работать.

Поскольку @deferэто часть шаблона компонента, это означает, что idleв большинстве случаев он обычно срабатывает сразу после первой визуализации компонента.
Встроенный триггер видового экрана с@placeholder

Очень распространенный вариант использования @defer— загрузка компонента только тогда (и если) он становится видимым в области просмотра браузера после прокрутки длинной страницы вниз.

При использовании этой стратегии страница сначала отображает контент над сгибом, который сразу же виден пользователю после загрузки страницы.

Остальной контент будет загружен только тогда, когда пользователь прокрутит страницу вниз.

Таким образом, начальная страница будет загружаться быстрее, и мы избежим загрузки кода, который пользователь может никогда не увидеть.

Для поддержки этого варианта использования у нас есть триггер viewport:

Пример:

@defer (on viewport) {
<large-component />
} @placeholder {
<loading-spinner />
}

В этом случае событие области просмотра будет вызвано, когда @placeholderблок станет видимым в области просмотра браузера.

Чтобы это работало, @placeholderблок должен содержать только один узел.
Встроенный триггер видового экрана без@placeholder

Если у нас нет заполнителя, мы все равно можем указать элемент, который запускает событие, viewportкогда оно появляется в поле зрения.

Это делается с помощью переменных шаблона:

Пример:

<div #title>Title</div>

@defer (on viewport(title)) {
<large-component />
}

Таким образом, триггер сработает, когда #titleэлемент станет видимым в области просмотра.
Взаимодействие встроенного триггера с@placeholder

Этот триггер срабатывает, когда пользователь напрямую взаимодействует с элементом страницы.

Взаимодействие происходит либо когда пользователь нажимает на целевой элемент, либо когда он что-то вводит в него, если элемент является входным.

Взаимодействие обнаруживается с помощью clickили keydownсобытий.

Пример:

@defer (on interaction) {
<large-component />
} @placeholder {
<placeholder-component />
}

В этом случае события взаимодействия детектируются в файле <placeholder-component />.
Взаимодействие встроенного триггера без@placeholder

Как и в случае с viewport, мы можем указать альтернативный элемент на странице, который инициирует событие interaction.

Это делается с помощью переменной шаблона.

Пример:

<div #title>Title</div>

@defer (on interaction(title)) {
<large-component />
}

Блок @deferбудет срабатывать только при #titleвзаимодействии с элементом.

Поскольку #titleэто элемент div, а не вход, это означает, что событие clickбудет использоваться для обнаружения взаимодействия.
Встроенный триггер наведения с@placeholder

Этот триггер срабатывает, когда пользователь наводит курсор на элемент страницы. События наведения — это mouseenterи focusin.

Пример:

@defer (on hover) {
<large-component />
} @placeholder {
<loading-spinner />
}

Эти события запускаются в @placeholderблоке при условии, что он содержит только один узел.
Встроенный триггер наведения без@placeholder

Мы также можем указать элемент, который будет вызывать @hoverсобытие при наведении на него курсора. Это делается с помощью переменных шаблона.

Пример:

<div #title>Title</div>

@defer (on hover(title)) {
<large-component />
}

Блок @deferсработает при #titleнаведении курсора мыши или фокусировке.
Немедленный встроенный триггер

Это @deferнемедленно вызывает блокировку. Он не ждет запуска какого-либо события.

Пример:

@defer (on immediate) {
<large-component />
}

Это означает, что нам даже не придется ждать, пока браузер бездействует, чтобы вызвать это событие.
Встроенный триггер таймера

Этот триггер срабатывает при достижении продолжительности таймера.

Пример:

@defer (on timer(5s)) {
<large-component />
}

Блокировка @deferсработает через 5 секунд.

Значение таймера может быть в миллисекундах (мс) или секундах (с).

И на этом мы рассмотрели все встроенные триггеры!

Давайте теперь поговорим о предварительной выборке.
Предварительная выборка @deferблоков

Предварительная выборка — это процесс загрузки ресурсов и хранения их в памяти до того, как они потребуются.

В предыдущих разделах мы продемонстрировали работу каждого встроенного триггера.

Но помните, при использовании @deferу нас есть два уровня контроля:

    мы можем контролировать, когда пакет будет предварительно получен из серверной части
    мы также можем контролировать, когда @deferблок будет отображаться пользователю

До сих пор мы настраивали только триггер отображения, оставляя триггер предварительной выборки в состоянии по умолчанию.

Итак, эта конфигурация:

@defer (on timer(5s)) {
<large-component />
}

Функционально эквивалентен:

@defer (on timer(5s); prefetch on idle) {
<large-component />
}

Как видите, пакет предварительно извлекается, когда браузер простаивает, что является поведением по умолчанию.

Но тогда значок <large-component />отображается пользователю только через 5 секунд, даже если предварительная выборка завершилась задолго до этого.

Триггер idle— отличный вариант по умолчанию для предварительной выборки, но мы также можем использовать любые другие встроенные триггеры, которые мы изучили, а также определить наши собственные триггеры.

Давайте посмотрим пару примеров того, что мы можем сделать с опцией предварительной выборки.
Предварительная выборка в окне просмотра, отображение при взаимодействии

Представьте, что у вас есть большой компонент ниже сгиба, поэтому вы хотите начать его загрузку только тогда, когда пользователь прокручивает страницу вниз.

Затем вы хотите отображать его только тогда, когда пользователь вводит что-то в поле ввода.

Вы можете сделать это следующим образом:

@defer (on interaction; prefetch on viewport) {
<large-component />
} @placeholder {
<input />
}

Как видите, все встроенные триггеры можно использовать как для предварительной выборки, так и для отображения блока @defer.

Мы можем объединить их для поддержки всех видов расширенных вариантов использования.

Но что, если существующие встроенные триггеры не делают именно то, что нам нужно?
Пользовательские @deferтриггеры с whenключевым словом

Если нам нужно, мы можем определить наши пользовательские триггеры, используя whenключевое слово.

Вот пример:

@Component({
selector: "app",
template: `
<button (click)="onLoad()">Trigger Prefetch</button>

    <button (click)="onDisplay()">Trigger Display</button>

    @defer(when show; prefetch when load) {
    <large-component />
    }
`,
})
export class AppComponent {
load: boolean = false;
show: boolean = false;

onLoad() {
this.load = true;
}

onDisplay() {
this.show = true;
}
}

В этом примере события предварительной выборки и отображения настраиваются с использованием пользовательских триггеров.

Это дает нам полную гибкость для реализации любых особых случаев, с которыми мы можем столкнуться.

Вот как это работает:

    нажмите кнопку «Предварительная загрузка», и загрузка пакета @deferJavascript начнется в фоновом режиме.

    Однако @deferблок пока не будет отображаться, поскольку showпеременная все еще имеет значение false.

    Затем нажмите кнопку «Показать», и @deferблок будет отображаться еще долго после завершения загрузки пакета.

    С другой стороны, обновите страницу и на этот раз сначала нажмите кнопку «Показать».

    Вы заметите, что это также вызовет предварительную выборку, а затем блок немедленно отобразится.

Это означает, что мы можем настроить собственный триггер предварительной выборки, но если триггер отображения сработает первым, предварительная выборка будет выполнена мгновенно, а условие предварительной выборки будет пропущено.

Это имеет смысл, поскольку мы не можем отобразить @deferблок без предварительной загрузки пакета.
Что происходит при @deferиспользовании рендеринга на стороне сервера?

Когда приложение отображается на сервере, все типичные события браузера недоступны в этом контексте.

Это означает, что событие простоя недоступно, равно как и событие таймера, а событие области просмотра не имеет смысла на сервере, поскольку нет понятия прокрутки и т. д.

Это означает, что большинство @deferтриггеров не имеют смысла в контексте сервера, поэтому все они игнорируются.

Итак, как тогда сервер может обрабатывать @deferблоки?

Сервер также не хочет сразу загружать содержимое блока @deferи отображать его, потому что это противоречит всей цели этой @deferфункции.

Единственное, что может сделать сервер, @defer— это выполнить первоначальный рендеринг блока @placeholder, если он существует.

Тогда во внешнем интерфейсе отложенная загрузка будет происходить как обычно, после запуска приложения.
Чем можно @deferсравнить с отложенной загрузкой?

Представьте себе приложение с 20 различными экранами, но для типичных пользовательских сессий обычно нужны только 2 или 3.

Зачем тогда загружать все 20 экранов одновременно?

Это задерживает запуск приложения и делает его медленнее.

Хуже того, по мере роста приложения увеличивается и количество экранов и компонентов, а время запуска приложения со временем будет увеличиваться.

Чтобы помочь в этом, Angular предоставляет нам отложенную загрузку компонентов на основе конфигурации маршрутизации.

Таким образом, если пользователь перейдет по определенному пути в браузере, только тогда будет загружен код для этого экрана.

Это уже очень помогает уменьшить размер нашего основного пакета приложений за счет разделения его на пакеты уровня экрана, которые содержат весь код для данного экрана.

Этот механизм на основе маршрутизатора известен как отложенная загрузка.

Но что, если вы хотите загрузить только часть экрана или только часть компонента?

Представьте, что на одном из ваших экранов есть масса компонентов, которые видны только в том случае, если пользователь прокручивает страницу вниз или когда пользователь вводит строку поиска и нажимает «Ввод».

Зачем изначально загружать код всех этих компонентов, если они могут даже не понадобиться пользователю?

Вот тут-то и @deferвозникает.

Синтаксис @deferпозволяет загружать части шаблона только при необходимости и при наличии логического условия.

Эта отложенная загрузка может быть вызвана различными событиями, например, когда пользователь прокручивает страницу вниз или нажимает кнопку.

Этот @deferмеханизм не связан с маршрутизатором, в отличие от отложенной загрузки, и он гораздо более детальный, у нас гораздо больше контроля над ним.

Эта @deferфункция не заменяет отложенную загрузку, а дополняет ее.

Эти две функции предназначены для совместного использования.
Что можно загрузить с помощью @defer?

Мы можем использовать только @deferдля загрузки автономных компонентов и их зависимостей: компонентов, директив, каналов, CSS и т. д.

Итак, еще одна веская причина перенести наши приложения на автономные компоненты, используя автоматическую миграцию, доступную через Angular CLI.
Как по @deferсравнению с @if?

Они служат двум совершенно разным целям. @deferне является заменой или альтернативой @if.

Это правда, что @deferпервоначально блок также будет спрятан при наличии логического условия, как и @if, но на этом сходство заканчивается.

При использовании @defer, как только срабатывает логическое условие и компонент загружается и отображается, пути назад уже нет.

При необходимости невозможно снова скрыть компонент с помощью @defer, это можно сделать только с помощью @if.

Поэтому, если вам нужно условно показать или скрыть компонент, который вы не хотите изначально загружать, объедините их:

@defer (on interaction; prefetch on viewport) {
@if (someCondition) {
<large-component />
}
@placeholder {
<placeholder-component />
}
}

При такой настройке файл <large-component />будет загружаться только тогда, когда пользователь прокручивает страницу вниз.

Затем блок @deferбудет применен к странице, но это не означает, что он <large-component />еще виден.

Будет <large-component />отображаться только в том случае, если someConditionусловие истинно, если условие ложно, оно останется скрытым.

Суть в том, что @deferон предназначен для контроля загрузки кода и его применения к компоненту, а также @ifдля управления видимостью компонента.
